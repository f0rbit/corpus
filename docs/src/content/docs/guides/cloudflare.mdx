---
title: Cloudflare Deployment
description: Deploy Corpus to Cloudflare Workers with D1 database and R2 object storage.
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabList, Tab, TabPanel } from '@f0rbit/ui';

This guide covers deploying Corpus to Cloudflare Workers using D1 for metadata and R2 for data storage.

## Prerequisites

<div class="grid">
  <div class="card">
    <div class="card-title">Cloudflare Account</div>
    <div class="card-description">Workers enabled on your account</div>
  </div>
  <div class="card">
    <div class="card-title">Wrangler CLI</div>
    <div class="card-description">Install with `npm install -g wrangler`</div>
  </div>
</div>

<Aside type="note">
  Initialize your project with `wrangler init` before proceeding.
</Aside>

## Setup

<div class="stepper stepper-vertical">
  <div class="step vertical-connector-item">
    <div class="step-indicator vertical-indicator">1</div>
    <div class="step-content vertical-content">
      <div class="step-title">Create D1 database and R2 bucket</div>
      <div class="step-body">
```bash
wrangler d1 create corpus-db
wrangler r2 bucket create corpus-bucket
```
      </div>
    </div>
    <div class="step-connector vertical-connector" />
  </div>

  <div class="step vertical-connector-item">
    <div class="step-indicator vertical-indicator">2</div>
    <div class="step-content vertical-content">
      <div class="step-title">Run the migration</div>
      <div class="step-body">
Create `migrations/0001_init.sql`:

```sql
CREATE TABLE IF NOT EXISTS corpus_snapshots (
  store_id TEXT NOT NULL,
  version TEXT NOT NULL,
  parents TEXT NOT NULL,
  created_at TEXT NOT NULL,
  invoked_at TEXT,
  content_hash TEXT NOT NULL,
  content_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  data_key TEXT NOT NULL,
  tags TEXT,
  PRIMARY KEY (store_id, version)
);

CREATE INDEX IF NOT EXISTS idx_store_created 
  ON corpus_snapshots(store_id, created_at);
CREATE INDEX IF NOT EXISTS idx_content_hash 
  ON corpus_snapshots(store_id, content_hash);
CREATE INDEX IF NOT EXISTS idx_data_key 
  ON corpus_snapshots(data_key);
```

Apply it:

```bash
wrangler d1 execute corpus-db --file=migrations/0001_init.sql
```

<Aside type="tip">
  You can also run the migration programmatically using `CORPUS_MIGRATION_SQL` exported from `@f0rbit/corpus`.
</Aside>
      </div>
    </div>
    <div class="step-connector vertical-connector" />
  </div>

  <div class="step vertical-connector-item">
    <div class="step-indicator vertical-indicator">3</div>
    <div class="step-content vertical-content">
      <div class="step-title">Configure wrangler.toml</div>
      <div class="step-body">
```toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[d1_databases]]
binding = "CORPUS_DB"
database_name = "corpus-db"
database_id = "<your-database-id>"

[[r2_buckets]]
binding = "CORPUS_BUCKET"
bucket_name = "corpus-bucket"
```
      </div>
    </div>
    <div class="step-connector vertical-connector" />
  </div>

  <div class="step vertical-connector-item">
    <div class="step-indicator vertical-indicator">4</div>
    <div class="step-content vertical-content">
      <div class="step-title">Create your Worker</div>
      <div class="step-body">
```typescript
import { z } from 'zod'
import { 
  create_corpus, 
  create_cloudflare_backend, 
  define_store, 
  json_codec 
} from '@f0rbit/corpus/cloudflare'

const CacheSchema = z.object({
  key: z.string(),
  value: z.unknown(),
  ttl: z.number().optional(),
})

interface Env {
  CORPUS_DB: D1Database
  CORPUS_BUCKET: R2Bucket
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const backend = create_cloudflare_backend({
      d1: env.CORPUS_DB,
      r2: env.CORPUS_BUCKET,
    })

    const corpus = create_corpus()
      .with_backend(backend)
      .with_store(define_store('cache', json_codec(CacheSchema)))
      .build()

    // Example: Store a cache entry
    const result = await corpus.stores.cache.put({
      key: 'greeting',
      value: 'Hello from Cloudflare!',
    })

    if (!result.ok) {
      return new Response(JSON.stringify(result.error), { status: 500 })
    }

    return new Response(JSON.stringify({
      version: result.value.version,
      hash: result.value.content_hash,
    }))
  },
}
```
      </div>
    </div>
    <div class="step-connector vertical-connector" />
  </div>

  <div class="step vertical-connector-item">
    <div class="step-indicator vertical-indicator">5</div>
    <div class="step-content vertical-content">
      <div class="step-title">Deploy</div>
      <div class="step-body">
```bash
wrangler deploy
```
      </div>
    </div>
  </div>
</div>

## SST Integration

If you're using [SST](https://sst.dev) for infrastructure as code, Corpus provides helper functions:

```typescript
// sst.config.ts
import { createCorpusInfra } from '@f0rbit/corpus'

const corpus = createCorpusInfra('myapp')

const db = new sst.cloudflare.D1(corpus.database.name)
const bucket = new sst.cloudflare.R2(corpus.bucket.name)

// Creates resources: 'myappDb' and 'myappBucket'
```

## Using the Cloudflare Entry Point

The `@f0rbit/corpus/cloudflare` entry point excludes the file backend (which requires Node.js APIs) for smaller bundle sizes in Workers:

<Tabs defaultValue="cloudflare" client:load>
<TabList client:load>
<Tab value="cloudflare" client:load>Cloudflare Workers</Tab>
<Tab value="node" client:load>Node.js / Bun</Tab>
</TabList>
<TabPanel value="cloudflare" client:load>
```typescript
// Smaller bundle, Workers-compatible
import { create_cloudflare_backend } from '@f0rbit/corpus/cloudflare'
```
</TabPanel>
<TabPanel value="node" client:load>
```typescript
// Full package with all backends
import { create_cloudflare_backend } from '@f0rbit/corpus'
```
</TabPanel>
</Tabs>

## Performance Tips

<Aside type="tip" title="Key optimizations">
  - Use layered backends for caching
  - Content is automatically deduplicated by hash
  - Reuse corpus instances across requests
</Aside>

### Batch Operations

When storing multiple items, consider using a layered backend with memory caching:

```typescript
const cache = create_memory_backend()
const cf = create_cloudflare_backend({ d1: env.DB, r2: env.BUCKET })

const backend = create_layered_backend({
  read: [cache, cf],   // Check cache first
  write: [cache, cf],  // Write to both
})
```

### Content Deduplication

Corpus automatically deduplicates content by hash. If you store the same data twice:
- Two metadata entries are created (different versions)
- Only one copy of the data is stored in R2
- The `data_key` in metadata points to the shared blob

### Minimize Cold Starts

Create the corpus once and reuse it across requests:

```typescript
let corpus: ReturnType<typeof create_corpus>['build'] | null = null

function getCorpus(env: Env) {
  if (corpus) return corpus
  
  const backend = create_cloudflare_backend({
    d1: env.CORPUS_DB,
    r2: env.CORPUS_BUCKET,
  })
  
  corpus = create_corpus()
    .with_backend(backend)
    .with_store(define_store('data', json_codec(DataSchema)))
    .build()
    
  return corpus
}
```

## Error Handling

Always check the `Result` type from operations:

```typescript
const result = await corpus.stores.cache.get(version)

if (!result.ok) {
  switch (result.error.kind) {
    case 'not_found':
      return new Response('Not found', { status: 404 })
    case 'storage_error':
      console.error('D1/R2 error:', result.error.cause)
      return new Response('Storage error', { status: 500 })
    default:
      return new Response('Error', { status: 500 })
  }
}

return new Response(JSON.stringify(result.value.data))
```

## See Also

<div class="grid">
  <a href="/corpus/guides/backends/" class="card card-interactive">
    <div class="card-title">Storage Backends</div>
    <div class="card-description">Learn about all available backends including memory and file.</div>
  </a>
  <a href="/corpus/guides/testing/" class="card card-interactive">
    <div class="card-title">Testing Patterns</div>
    <div class="card-description">Use the memory backend for fast, isolated tests.</div>
  </a>
</div>
